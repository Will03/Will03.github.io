---
title: CVE-2020-16898 - Microsoft badneighbor
date: 2020-11-11 08:00:00 +0800
categories: [ CVE ]
tags: [ Windows ]     # TAG names should always be lowercase
---

這次記錄的是在 2020 10 月 Windows 所修補的 Ping of death(POD) 漏洞攻擊，POD 是一種透過發送惡意 ICMP 封包來攻擊目標電腦的手法，輕微可以造成目標電腦 DOS ，精細一點甚至可以構造成 RCE 攻擊。

微軟發布的[漏洞公告原文](https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-16898)
>A remote code execution vulnerability exists when the Windows TCP/IP stack improperly handles ICMPv6 Router Advertisement packets. An attacker who successfully exploited this vulnerability could gain the ability to execute code on the target server or client.
>To exploit this vulnerability, an attacker would have to send specially crafted ICMPv6 Router Advertisement packets to a remote Windows computer.
>The update addresses the vulnerability by correcting how the Windows TCP/IP stack handles ICMPv6 Router Advertisement packets.

由於這次漏洞使用的是 ICMPv6 協定，所以先來簡單的說明一下 IPv6 的網路運作方式

在IPv6的環境電腦進入區網後會利用 ICMPv6 的 Router Solicitation (RS) message 告知區網 IPv6 的路由器，路由器接收到RS後接著發送Routing Advertisement (RA) message 給區網內的所有設備 (類似IPv4 的廣播封包)，這個 RA message 也會依據路由器需要在變更網路設定時發送。

說到這回頭看一下剛剛提到的 RS message 和 RA message 這兩個訊息，他們其實是由 Neighbor Discovery Protocol (NDP) 所規範的 ICMPv6 方法，如下全部共有五種。

![](/image/2020-11-11/icmpv6.png)

想了解的更細可以參考 [NDP WIKI](https://en.wikipedia.org/wiki/Neighbor_Discovery_Protocol)

先使用 ping 來驗證一下 IPv6 的傳輸流程，如下圖為發送一次ping 的結果，可以看到總共會出現 4 個封包，可以切分成兩個步驟，一開始先向 router 傳送 NS message (Destination IP)，router 會請 Destination 回傳一個 NA 封包到 Source，接到訊息後就可以開始傳送 ping 封包

![](/image/2020-11-11/wireshark1.png)


## Neighbor Discovery Protocol
為了了解漏洞成因接著要深入探討協定規格

### Neighbor Advertisement (NA) Message Format 
[rfc4861](https://tools.ietf.org/html/rfc4861) 
這邊記錄著 NA 封包的格式，可以比對一下剛剛用 ping 得到的 NA 封包，就可以把格式對上了，這次漏洞的漏點在於 optional 這個欄位

![](/image/2020-11-11/NAformat.png)

### Recursive DNS Server Option
[rfc6106](https://tools.ietf.org/html/rfc6106#section-5.1) 這份是 RDNSS 的規格說明，RDNSS 的用途在於向各個主機廣播目前 DNS Recursive Server Address，讓主機可以做 DNS 查詢，如下圖可以看到RDNSS 的封包格式，這次的漏洞出現在解析 RDNSS 封包時假如 length 和所給的 IPv6 ip 不對稱時用來處理封包的 `tcpip.sys` 會發生 stack-based 的漏洞。

![](/image/2020-11-11/RDNSformat.png)



## 漏洞分析
RDNSS 的 length 是以 8 個 byte 為一個單位，前面的 Type, Length, Reserved, Lifetime 佔用了 8 bytes (64 bits)，而一個 IPv6 佔用 16 bytes (128 bits)，因此 length 最少為3 並且永遠都是單數
```
 Length        8-bit unsigned integer.  The length of the option
                   (including the Type and Length fields) is in units of
                   8 octets.  The minimum value is 3 if one IPv6 address
                   is contained in the option.  Every additional RDNSS
                   address increases the length by 2.  The Length field
                   is used by the receiver to determine the number of
                   IPv6 addresses in the option.
```

漏洞的發生處在 tcpip.sys ->  Ipv6pHandleRouterAdvertisement

由於在計算offset 時 程式會透過 `(length - 1 ) / 2`，來確定其ipv6 的個數，然而當我們刻意構造偶數的 length 數值時就會產生問題，像是 (3-1) / 2 和 (4-1) / 2 得到的數值都是同樣的。利用這個特性，攻擊者可以繞過檢查，偽造出有問題的option 包，造成 heap overflow

### POC
漏洞公布後的兩週開始陸續有人公布 POC，我這邊使用的是這個
`http://site.pi3.com.pl/exp/p_CVE-2020-16898.py`


---
## 漏洞復現

### 環境設定

#### Unpatch security update

查看漏洞在 windows 的更新編號，以及版本是否在受害範圍內

![](/image/2020-11-11/securityupdate.png)

大部分的電腦都會自動上 patch 所以要在自己的環境稍微檢查一下，如果如下圖有看到 KB4580330 的 update，代表微軟爸爸幫你上 Patch 了，要把這個 patch 給解除安裝

![](/image/2020-11-11/unpatch.png)

#### 確認網卡是否有安裝 ipv6

![](/image/2020-11-11/addfeature.png)


#### 確定是否有開啟 IPv6 和 RDNSS

在 cmd 下 `netsh int ipv6 sh int`

找到使用網卡的 index 後，執行下面指令並填入網卡 id

`netsh int ipv6 sh in <id>`

![](/image/2020-11-11/RDNSopen.png)

這樣環境就準備就緒

### POC
更改 POC 的攻擊者和受害者位址

成功觸發漏洞

![](/image/2020-11-11/broken.png)

### Conclusion
本篇較為粗淺的講述漏洞最根本的成因，接著透過網路上的 POC 腳本進行攻擊，在環境設定的部分讀者可以記住如何對應漏洞和Security Patch 的方式，如果之後要復現其他漏洞步驟也差不多是這樣。

---
### Reference
- https://en.wikipedia.org/wiki/Neighbor_Discovery_Protocol
- http://hackdig.com/11/hack-190997.htm
- https://cert.360.cn/report/detail?id=771d8ddc2d703071d5761b6a2b139793